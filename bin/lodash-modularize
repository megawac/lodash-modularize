#!/usr/bin/env node

var argv = require('yargs')
  .usage('Usage: $0 <input> [options]')
  .example('$0 src/**.js --format amd -o src/lodash.js --lodash-path bower/lodash', 'Generate a UMD build for source files')
  .example('$0 src/**.js -g _ --exports es6', 'Generate a UMD build for source files')
  .example('$0 src/**.js --list', 'List the used lodash functions')
  .demand(1)

  .default('output', null)
  .alias('o', 'output')
  .nargs('o', 1)
  .describe('output', 'file to generate')
  
  .boolean('update')
  .alias('update', ['u'])
  .implies('update', 'output')
  .describe('update', 'Update the files using lodash to use the built file')

  .boolean('production')
  .implies('production', 'output')
  .describe('production', 'Generate an optimized & minified build')

  .default('format', ['cjs', 'es6'])
  .alias('f', 'format')
  .nargs('f', 1)
  .describe('format', 'modular format to export (es6,amd,cjs)')

  .default('exports', 'umd')
  .describe('exports', 'module format to export (es6,umd,cjs,amd)')

  .default('lodash', 'lodash')
  .describe('lodash', 'The path to search and use for lodash (e.g. lodash-compat)')

  .default('lodash-path', null)
  .describe('lodash-path', 'Lodash base path (useful for AMD)')
  
  .default('global', null)
  .alias('g', 'global')
  .nargs('g', 1)
  .describe('global', 'Global lodash variable (e.g. _ or lodash)')

  .boolean('compile')
  .alias('compile', ['c'])
  .describe('compile', 'Whether to compile the results like lodash cli')

  .boolean('list')
  .describe('list', 'List the use lodash modules instead of building a file')

  .version(function() {
    return require('../package').version;
  })
  .argv;

// I want it all
require('bluebird').longStackTraces();
require('colors');
var modularize = require('..');

argv.lodashPath = argv.lodashPath || argv.lodash;

// Work around yargs not doing it for us
argv.format = argv.f = argv.f.join(',').split(',');

modularize(argv._, argv)
  .then(function(result) {
    if (argv.list) {
      console.log(result.join(',').bold);
      return;
    } else if (!argv.output) {
      console.log(result);
    }
  })
  .catch(function(error) {
    // process.exit(1) after the error is outputted
    setTimeout(process.exit, 100, 1);
    throw error.red.bold;
  });

